n_to_label <- 20 # max number of nodes to label in the node plots
node_analysis_list <- vector("list", length = length(mymethods))
for(i in seq_along(mymethods)){
# create the dfs, one for spiec-easi and one for sparCC and only select FMBN
# only select nodes with degree>0
FMBN_node_df <- node_stats_df %>%
dplyr::filter(method == mymethods[i]) %>%
dplyr::filter(degree>0) %>%
mutate(Study = as.factor(Study),
rel_pos_degree = pos_degree / sum(pos_degree)) %>%
dplyr::rename(tlabel = label)
# use a loop to do the node degree graphs, print them and put them in a list
node_degree_plot_list <- vector("list", length=nlevels(FMBN_node_df$study))
for(j in seq_along(levels(FMBN_node_df$Study))){
gtitle = paste(levels(FMBN_node_df$Study)[j], mymethods[i], sep = ", ")
temp_df <- FMBN_node_df %>%
dplyr::filter(Study ==levels(FMBN_node_df$Study)[j]) %>%
mutate(dgr = pos_degree + neg_degree) %>%
arrange(-dgr) %>%
rowid_to_column() %>%
mutate(to_label = if_else((rowid<=20 | is_hub), tlabel, NA_character_))
ave_degree = mean(temp_df$dgr, na.rm = T)
ave_pos_degree = mean(temp_df$pos_degree, na.rm = T)
# creating the plot, only the names of the top 20 nodes (in terms of degree)
# are plotted, hubs are always plotted
ggp <- ggplot(
temp_df,
mapping = aes(
x = pos_degree,
y = dgr,
label = str_trunc(genus, 12, side = "center")
)
) +
geom_smooth(method = "lm", linetype = 3, se = F, color = I("black"), show.legend = F) +
geom_point(mapping = aes(color = phylum,
size = relAbundance,
alpha = between)) +
geom_text_repel(show.legend = F, max.overlaps = 20, alpha = I(0.5)) +
geom_abline(slope = 1, intercept = 0, linetype = 1) +
geom_hline(yintercept = ave_degree, linetype = 3, show.legend = F) +
geom_vline(xintercept = ave_pos_degree, linetype = 3, show.legend = F) +
scale_alpha_continuous(range = c(0.4, 1)) +
scale_size_continuous(range = c(1,6)) +
labs(
x = "positive degree",
y = "degree",
size = "relative abundance",
alpha = "betweenness",
title = gtitle
) +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
print(ggp)
node_degree_plot_list[[j]] <- ggp
names(node_degree_plot_list[[j]]) <- gtitle
}
file_name <- paste(file.path(output_folder,out_filename_pref), "_", mymethods[i], "_nodeplots.Rdata",sep="")
save(node_degree_plot_list, file = file_name)
# calculate frequency for hubs (meaningful only if you have many taxa and the percentile for hub detection is low, say 0.75-0.90)
n_datasets <- dplyr::n_distinct(FMBN_node_df$dataset)
FMBN_node_df_hubs <- FMBN_node_df %>%
dplyr::filter(is_hub == T) %>%
group_by(tlabel, phylum, class) %>%
summarise(hub_freq = n()/n_datasets) %>%
arrange(-hub_freq)
cat("method", mymethods[i], "hub frequency", "\n")
head(FMBN_node_df_hubs, 20)
# save elements in the list
node_analysis_list[[i]] <- list(
node_df = FMBN_node_df,
plot_list = node_degree_plot_list,
node_df_hubs = FMBN_node_df_hubs
)
names(node_analysis_list)[i]<- mymethods[i]
}
if(play_audio) beep(sound = 6)
if(keep_time) toc()
rm(FMBN_node_df, node_degree_plot_list, temp_df, FMBN_node_df_hubs)
if(keep_time) tic("Edge analysis")
# this calculates the empirical quantile of edge betweenness
# by dataset and method: I suppose one can then select those >0.95
# to get a sort of hubness for edges, but it makes sense only for
# large number of edges
edge_list_df <- edge_list_df %>% group_by(dataset, method) %>%
mutate(ebq = ecdf(edge_betw)(edge_betw)) %>% ungroup()
# calculate the frequency of edges, by study and type and
# median value and IQR for IQR
# this only checks for conserved edges across methods
edge_freq_bystudy <- edge_list_df %>%
group_by(dataset, asso_type, edge_name) %>%
summarise(n = n(),
med_ebq = median(ebq),
iqr_ebq = IQR(ebq)) %>%
arrange(-n, -med_ebq, ) %>%
ungroup()
# I am now generating a plot may be with the top 50 edges, only for FMBN studies
edge_freq_bystudy_FMBN <- edge_freq_bystudy %>%
dplyr::filter(str_detect(dataset, "FMBN")) %>%
arrange(-n, -med_ebq)
# let's try a plot (gives an emphasis to most stable edges)
slice_to_plot <- slice(edge_freq_bystudy_FMBN, 1:50) %>%
mutate(edge_name = forcats::fct_reorder(edge_name, med_ebq))
ggplot(slice_to_plot,
mapping = aes(x = edge_name, y = med_ebq, size = n, color = asso_type)) +
geom_point() +
coord_flip() +
labs(x = "edge", y = "edge betweenness quantile",
size = "edge freq.") +
scale_colour_manual(values = c("green","red"))
# same, by method and assotype, only for FMBN
# only meaningful for high number of studies
edge_freq_bymethod <- edge_list_df %>%
dplyr::filter(str_detect(dataset, "FMBN")) %>%
group_by(method, asso_type) %>%
count(edge_name) %>%
arrange(method, asso_type, -n)
# The following section evaluates taxonomic assortativity (i.e. evaluates if
# copresence associations are more frequent among members of the same
# family, order or class). The odds ratio of copresence relationships within
# the same family is calculated using epiR::epi.2by2()
# first, add taxonomy to the
unique_tax <- node_stats_df %>%
dplyr::select(label, domain:species) %>%
distinct()
edge_list_df_wtaxa <- edge_list_df
edge_list_df_wtaxa <- left_join(edge_list_df_wtaxa,
dplyr::select(unique_tax, label, class, order, family),
by = c("from_name" = "label")) %>%
dplyr::rename(from_class = class, from_order = order, from_family = family)
edge_list_df_wtaxa <- left_join(edge_list_df_wtaxa,
dplyr::select(unique_tax, label, class, order, family),
by = c("to_name" = "label")) %>%
dplyr::rename(to_class = class, to_order = order, to_family = family)
# check if same family or same class
edge_list_df_wtaxa <- edge_list_df_wtaxa %>%
mutate(same_class = if_else(from_class == to_class, T, F),
same_order = if_else(from_order == to_order, T, F),
same_family = if_else(from_family == to_family, T, F)
)
# use a loop to calculate odds ratios and probabilities
# get the number of studies
edge_list_df_wtaxa <- edge_list_df_wtaxa %>%
separate(dataset, into = c("study", "col2", "col3"), remove = F) %>%
select(-col2, -col3) %>%
mutate(study = as.factor(study),
sf = factor(same_family, levels = c("TRUE", "FALSE")),
so = factor(same_order, levels = c("TRUE", "FALSE")),
sc = factor(same_class, levels = c("TRUE", "FALSE"))
)
assort_results_list <- vector(mode = "list", length = nlevels(edge_list_df_wtaxa$study))
taxo_level_selection <- "family"
for(i in seq_along(levels(edge_list_df_wtaxa$study))){
input_df_study <- edge_list_df_wtaxa %>% dplyr::filter(study == levels(study)[i]) %>%
mutate(method = as.factor(method))
inner_result_list <- vector(mode = "list", length = nlevels(input_df_study$method))
for(j in seq_along(levels(input_df_study$method))){
input_df_method <- input_df_study %>%
mutate(method = as.factor(method)) %>%
dplyr::filter(method == levels(method)[j])
inner_result_list[[j]]<-try(odds_ratio(input_df_method, taxo_level = taxo_level_selection))
names(inner_result_list)[j]<- levels(input_df_method$method)[j]
}
assort_results_list[[i]] <- inner_result_list
names(assort_results_list)[i] <- levels(edge_list_df_wtaxa$study)[i]
}
# clean-up the list and put together the data frames
df_list <- vector(mode = "list", length = length(assort_results_list))
for(i in seq_along(assort_results_list)){
df_list[[i]] <- df_return(assort_results_list[[i]])
names(df_list)[i]<-names(assort_results_list)[i]
}
assort_results_df <- bind_rows(df_list, .id = "study")
# create dummy ORest values by replacing Inf
assort_results_df <- assort_results_df %>%
mutate(OR_est_wdummy = if_else(OR_est==Inf, 99, OR_est)) %>%
mutate(lOR_est_wdummy = log(OR_est_wdummy),
significant = if_else(OR_p.value <=0.05, T, F))
# plot, studies are pooled
ggplot(assort_results_df, mapping = aes(x = assort_test, y = lOR_est_wdummy, colour = significant)) +
facet_wrap(~method) +
geom_jitter(width = 0.2) +
labs(y = "odds ratio")
rm(assort_results_list, input_df_study, inner_result_list, input_df_method, i, j, df_list)
if(play_audio) beep(sound = 6)
if(keep_time) toc()
all_packages <- c("base", .cran_packages, .bioc_packages, .github_packages)
map(all_packages, citation)
# for reproducibility you should also run
# sessionInfo()
View(study_metadata)
load("~/Google Drive (eugenio.parente@unibas.it)/GitHub_repos/Microbial_Association_Networks_Cheese/MAN_in_cheese/Workflow/MAN_NetCoMi_FMBN_genus_example.RData")
rm(a)
View(assort_results_df)
save.image("~/Google Drive (eugenio.parente@unibas.it)/GitHub_repos/Microbial_Association_Networks_Cheese/MAN_in_cheese/Workflow/MAN_NetCoMi_FMBN_genus_example.RData")
load("~/Google Drive (eugenio.parente@unibas.it)/GitHub_repos/MAN_in_cheese/Workflow/MAN_NetCoMi_FMBN_genus_example.Rmd")
knitr::opts_chunk$set(echo = TRUE)
# Install/load packages ---------------------------------------------------
.bioc_packages <- c("BiocManager", "genefilter", "phyloseq")
.cran_packages <- c("devtools", "parallel", "tidyverse", "igraph",
"VennDiagram", "tidygraph", "lobstr", "tictoc", "beepr",
"psych", "GGally", "ggrepel", "ggraph", "egg", "epiR")
.github_packages <- c("SpiecEasi","NetCoMi")
# lobstr is called for lobstr::obj_size()
# egg is only used to arrange plots in grids
.inst <- .bioc_packages %in% installed.packages()
if(any(!.inst)) {
if(!.inst[1]) {
install.packages("BiocManager")
.inst <- .bioc_packages %in% installed.packages()
}
if(any(!.inst[2:length(.inst)])) {
BiocManager::install(.bioc_packages[!.inst], ask = F)
}
}
.inst <- .cran_packages %in% installed.packages()
if(any(!.inst)) {
install.packages(.cran_packages[!.inst])
}
.inst <- .github_packages %in% installed.packages()
# careful now, because the installation of NetCoMi can be buggy
# it usually fails because if fails to install one of the missing dependencies,
# if any. If this happens, install the dependencies first...
if(any(!.inst)){
require(devtools)
if(!.inst[1]) devtools::install_github("zdk123/SpiecEasi")
if(!.inst[2]) devtools::install_github("stefpeschel/NetCoMi",
dependencies = TRUE,
repos = c("https://cloud.r-project.org/",
BiocManager::repositories()))
}
# Load packages into session, and print package version
sapply(c(.cran_packages, .bioc_packages, .github_packages), require, character.only = TRUE)
# other setup operations
opar <- par(no.readonly=TRUE)
par(ask=F)
# set.seed(1234)
# play audio notifications
play_audio <- T
# time important steps
keep_time <- T
# verbose output: will print additional objects and messages
verbose_output <- T
# load the functions and return a report
source(file.path("source","MAN_functions.R"))
if(play_audio) beep(sound = 6) # notification
odds_ratio <- function(inputdf, taxo_level = "family"){
epiR_version <- packageVersion("epiR")
if(epiR_version < "2.0.26"){
stop("\nYou must update epiR to version 2.0.26 or higher!")
}
mini_df <- switch(taxo_level,
family = select(inputdf, asso_type, sf),
order = select(inputdf, asso_type, so),
class = select(inputdf, asso_type, sc)
)
colnames(mini_df)[2] <- "same_taxon"
# copresence
epi_list_cop <- epiR::epi.2by2(xtabs(~same_taxon + asso_type, data = mini_df))
# extract in a data frame the Wald incidence risk ratio
# extracts the appropriate chisq values
chicop <- if(epi_list_cop$massoc.detail$chi2.correction){
epi_list_cop$massoc.detail$chi2.strata.yates
} else {
epi_list_cop$massoc.detail$chi2.strata.uncor
}
OR <- cbind(epi_list_cop$massoc.detail$OR.strata.wald, chicop)
names(OR) <- str_c("OR", names(OR), sep = "_")
RR <- epi_list_cop$massoc.detail$RR.strata.wald
names(RR) <- str_c("RR", names(RR), sep = "_")
assort_results <- cbind(
OR,
RR
)
return(assort_results)
}
# same, by method and assotype, only for FMBN
# only meaningful for high number of studies
edge_freq_bymethod <- edge_list_df %>%
dplyr::filter(str_detect(dataset, "FMBN")) %>%
group_by(method, asso_type) %>%
count(edge_name) %>%
arrange(method, asso_type, -n)
load("~/Google Drive (eugenio.parente@unibas.it)/GitHub_repos/MAN_in_cheese/Workflow/MAN_NetCoMi_FMBN_genus_example.RData")
# same, by method and assotype, only for FMBN
# only meaningful for high number of studies
edge_freq_bymethod <- edge_list_df %>%
dplyr::filter(str_detect(dataset, "FMBN")) %>%
group_by(method, asso_type) %>%
count(edge_name) %>%
arrange(method, asso_type, -n)
# first, add taxonomy to the
unique_tax <- node_stats_df %>%
dplyr::select(label, domain:species) %>%
distinct()
edge_list_df_wtaxa <- edge_list_df
edge_list_df_wtaxa <- left_join(edge_list_df_wtaxa,
dplyr::select(unique_tax, label, class, order, family),
by = c("from_name" = "label")) %>%
dplyr::rename(from_class = class, from_order = order, from_family = family)
edge_list_df_wtaxa <- left_join(edge_list_df_wtaxa,
dplyr::select(unique_tax, label, class, order, family),
by = c("to_name" = "label")) %>%
dplyr::rename(to_class = class, to_order = order, to_family = family)
# check if same family or same class
edge_list_df_wtaxa <- edge_list_df_wtaxa %>%
mutate(same_class = if_else(from_class == to_class, T, F),
same_order = if_else(from_order == to_order, T, F),
same_family = if_else(from_family == to_family, T, F)
)
edge_list_df_wtaxa <- edge_list_df_wtaxa %>%
separate(dataset, into = c("study", "col2", "col3"), remove = F) %>%
select(-col2, -col3) %>%
mutate(study = as.factor(study),
sf = factor(same_family, levels = c("TRUE", "FALSE")),
so = factor(same_order, levels = c("TRUE", "FALSE")),
sc = factor(same_class, levels = c("TRUE", "FALSE"))
)
assort_results_list <- vector(mode = "list", length = nlevels(edge_list_df_wtaxa$study))
taxo_level_selection <- "family"
for(i in seq_along(levels(edge_list_df_wtaxa$study))){
input_df_study <- edge_list_df_wtaxa %>% dplyr::filter(study == levels(study)[i]) %>%
mutate(method = as.factor(method))
inner_result_list <- vector(mode = "list", length = nlevels(input_df_study$method))
for(j in seq_along(levels(input_df_study$method))){
input_df_method <- input_df_study %>%
dplyr::filter(method == levels(method)[j])
if(verbose_output) cat("\nProcessing", levels(edge_list_df_wtaxa$study)[i],
"method", levels(input_df_method$method)[j],"\n")
inner_result_list[[j]]<-try(odds_ratio(input_df_method, taxo_level = taxo_level_selection))
if(verbose_output & class(inner_result_list[[j]]) == "data.frame") {
cat("\nSuccess! Odds ratio estimated")
} else {
cat("\nFail: unable to return test results!")
}
names(inner_result_list)[j]<- levels(input_df_method$method)[j]
}
assort_results_list[[i]] <- inner_result_list
names(assort_results_list)[i] <- levels(edge_list_df_wtaxa$study)[i]
}
df_list <- vector(mode = "list", length = length(assort_results_list))
for(i in seq_along(assort_results_list)){
df_list[[i]] <- df_return(assort_results_list[[i]])
names(df_list)[i]<-names(assort_results_list)[i]
}
assort_results_df <- bind_rows(df_list, .id = "study")
View(assort_results_df)
odds_ratio <- function(inputdf, taxo_level = "family"){
epiR_version <- packageVersion("epiR")
if(epiR_version < "2.0.26"){
stop("\nYou must update epiR to version 2.0.26 or higher!")
}
mini_df <- switch(taxo_level,
family = select(inputdf, asso_type, sf),
order = select(inputdf, asso_type, so),
class = select(inputdf, asso_type, sc)
)
colnames(mini_df)[2] <- "same_taxon"
# copresence
epi_list_cop <- epiR::epi.2by2(xtabs(~same_taxon + asso_type, data = mini_df))
# extract in a data frame the Wald incidence risk ratio
# extracts the appropriate chisq values
chicop <- if(epi_list_cop$massoc.detail$chi2.correction){
epi_list_cop$massoc.detail$chi2.strata.yates
} else {
epi_list_cop$massoc.detail$chi2.strata.uncor
}
OR <- cbind(epi_list_cop$massoc.detail$OR.strata.wald, chicop)
names(OR) <- str_c("OR", names(OR), sep = "_")
RR <- epi_list_cop$massoc.detail$RR.strata.wald
names(RR) <- str_c("RR", names(RR), sep = "_")
assort_results <- cbind(
OR,
RR
)
return(assort_results)
}
assort_results_list <- vector(mode = "list", length = nlevels(edge_list_df_wtaxa$study))
taxo_level_selection <- "family"
for(i in seq_along(levels(edge_list_df_wtaxa$study))){
input_df_study <- edge_list_df_wtaxa %>% dplyr::filter(study == levels(study)[i]) %>%
mutate(method = as.factor(method))
inner_result_list <- vector(mode = "list", length = nlevels(input_df_study$method))
for(j in seq_along(levels(input_df_study$method))){
input_df_method <- input_df_study %>%
dplyr::filter(method == levels(method)[j])
if(verbose_output) cat("\nProcessing", levels(edge_list_df_wtaxa$study)[i],
"method", levels(input_df_method$method)[j],"\n")
inner_result_list[[j]]<-try(odds_ratio(input_df_method, taxo_level = taxo_level_selection))
if(verbose_output & class(inner_result_list[[j]]) == "data.frame") {
cat("\nSuccess! Odds ratio estimated")
} else {
cat("\nFail: unable to return test results!")
}
names(inner_result_list)[j]<- levels(input_df_method$method)[j]
}
assort_results_list[[i]] <- inner_result_list
names(assort_results_list)[i] <- levels(edge_list_df_wtaxa$study)[i]
}
df_list <- vector(mode = "list", length = length(assort_results_list))
for(i in seq_along(assort_results_list)){
df_list[[i]] <- df_return(assort_results_list[[i]])
names(df_list)[i]<-names(assort_results_list)[i]
}
assort_results_df <- bind_rows(df_list, .id = "study")
View(assort_results_df)
# create dummy ORest values by replacing Inf
assort_results_df <- assort_results_df %>%
mutate(OR_est_wdummy = if_else(OR_est==Inf, 99, OR_est)) %>%
mutate(lOR_est_wdummy = log(OR_est_wdummy),
significant = if_else(OR_p.value.1s <=0.05, T, F))
# plot, studies are pooled
ggplot(assort_results_df, mapping = aes(x = method, y = lOR_est_wdummy, colour = significant)) +
geom_jitter(width = 0.2) +
labs(y = "log(odds ratio)") +
theme_bw() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# plot, studies are pooled
ggplot(assort_results_df, mapping = aes(x = method, y = lOR_est_wdummy, colour = significant)) +
geom_jitter(width = 0.2) +
labs(y = "log(odds ratio)") +
theme_bw() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# tabulating
xtabs(~ method + significant +assort_test , data = assort_results_df)
# tabulating
xtabs(~ method + significant , data = assort_results_df)
# same, by method and assotype, only for FMBN
# only meaningful for high number of studies
edge_freq_bymethod <- edge_list_df %>%
dplyr::filter(str_detect(dataset, "FMBN")) %>%
group_by(method, asso_type) %>%
count(edge_name) %>%
arrange(method, asso_type, -n)
# The following section evaluates taxonomic assortativity (i.e. evaluates if
# copresence associations are more frequent among members of the same
# family, order or class). The odds ratio of copresence relationships within
# the same family is calculated using epiR::epi.2by2()
# first, add taxonomy to the
unique_tax <- node_stats_df %>%
dplyr::select(label, domain:species) %>%
distinct()
edge_list_df_wtaxa <- edge_list_df
edge_list_df_wtaxa <- left_join(edge_list_df_wtaxa,
dplyr::select(unique_tax, label, class, order, family),
by = c("from_name" = "label")) %>%
dplyr::rename(from_class = class, from_order = order, from_family = family)
edge_list_df_wtaxa <- left_join(edge_list_df_wtaxa,
dplyr::select(unique_tax, label, class, order, family),
by = c("to_name" = "label")) %>%
dplyr::rename(to_class = class, to_order = order, to_family = family)
# check if same family or same class
edge_list_df_wtaxa <- edge_list_df_wtaxa %>%
mutate(same_class = if_else(from_class == to_class, T, F),
same_order = if_else(from_order == to_order, T, F),
same_family = if_else(from_family == to_family, T, F)
)
# use a loop to calculate odds ratios and probabilities
# get the number of studies
edge_list_df_wtaxa <- edge_list_df_wtaxa %>%
separate(dataset, into = c("study", "col2", "col3"), remove = F) %>%
select(-col2, -col3) %>%
mutate(study = as.factor(study),
sf = factor(same_family, levels = c("TRUE", "FALSE")),
so = factor(same_order, levels = c("TRUE", "FALSE")),
sc = factor(same_class, levels = c("TRUE", "FALSE"))
)
assort_results_list <- vector(mode = "list", length = nlevels(edge_list_df_wtaxa$study))
taxo_level_selection <- "family"
for(i in seq_along(levels(edge_list_df_wtaxa$study))){
input_df_study <- edge_list_df_wtaxa %>% dplyr::filter(study == levels(study)[i]) %>%
mutate(method = as.factor(method))
inner_result_list <- vector(mode = "list", length = nlevels(input_df_study$method))
for(j in seq_along(levels(input_df_study$method))){
input_df_method <- input_df_study %>%
dplyr::filter(method == levels(method)[j])
if(verbose_output) cat("\nProcessing", levels(edge_list_df_wtaxa$study)[i],
"method", levels(input_df_method$method)[j],"\n")
inner_result_list[[j]]<-try(odds_ratio(input_df_method, taxo_level = taxo_level_selection))
if(verbose_output & class(inner_result_list[[j]]) == "data.frame") {
cat("\nSuccess! Odds ratio estimated")
} else {
cat("\nFail: unable to return test results!")
}
names(inner_result_list)[j]<- levels(input_df_method$method)[j]
}
assort_results_list[[i]] <- inner_result_list
names(assort_results_list)[i] <- levels(edge_list_df_wtaxa$study)[i]
}
# clean-up the list and put together the data frames
df_list <- vector(mode = "list", length = length(assort_results_list))
for(i in seq_along(assort_results_list)){
df_list[[i]] <- df_return(assort_results_list[[i]])
names(df_list)[i]<-names(assort_results_list)[i]
}
assort_results_df <- bind_rows(df_list, .id = "study")
# create dummy ORest values by replacing Inf
assort_results_df <- assort_results_df %>%
mutate(OR_est_wdummy = if_else(OR_est==Inf, 99, OR_est)) %>%
mutate(lOR_est_wdummy = log(OR_est_wdummy),
significant = if_else(OR_p.value.1s <=0.05, T, F))
# plot, studies are pooled
ggplot(assort_results_df, mapping = aes(x = method, y = lOR_est_wdummy, colour = significant)) +
geom_jitter(width = 0.2) +
labs(y = "log(odds ratio)") +
theme_bw() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# tabulating
xtabs(~ method + significant , data = assort_results_df)
rm(assort_results_list, input_df_study, inner_result_list, input_df_method, i, j, df_list)
if(play_audio) beep(sound = 6)
if(keep_time) toc()
save.image("~/Google Drive (eugenio.parente@unibas.it)/GitHub_repos/MAN_in_cheese/Workflow/MAN_NetCoMi_FMBN_genus_example.RData")
